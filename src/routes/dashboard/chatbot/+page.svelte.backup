<script lang="ts">
	import { onMount } from 'svelte';
	import {
		dbChatsToTree,
		getActivePath,
		createFork,
		addAIResponse,
		goToParent,
		goToNext,
		getNavigationInfo,
		getConversationTitle,
		getLastMessage,
		getConversationCreatedAt,
		type ChatTree,
		type ChatTreeNode,
		type ConversationState
	} from '$lib/utils/chat-tree-v3';
	import MessageRenderer from './MessageRenderer.svelte';

	// Conversation-based tree management
	let conversations: Record<string, ChatTree> = {}; // Each conversation has its own tree
	let currentConversationId: string | null = null;
	let currentNodeId: string | null = null;

	// Get the current conversation's tree
	$: currentChatTree = currentConversationId ? conversations[currentConversationId] || {} : {};

	// UI state
	let input = '';
	let isLoading = false;
	let showHistory = true;
	let editingMessageId: string | null = null;
	let editingContent = '';

	// Computed values for current conversation
	$: messages = getActivePath(currentChatTree, currentNodeId);

	// Fallback: if no messages from path, show all messages in current conversation
	$: displayMessages = messages.length > 0 ? messages :
		(currentConversationId ? Object.values(currentChatTree).filter(node =>
			node.conversationId === currentConversationId
		).sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()) : []);

	// Navigation info
	$: navigationInfo = currentNodeId ? getNavigationInfo(currentChatTree, currentNodeId) : {
		hasParent: false,
		hasNext: false,
		hasChildren: false,
		parentId: null,
		nextId: null,
		childIds: []
	};

	// Get list of conversations for the sidebar
	$: conversationList = Object.keys(conversations).map(convId => ({
		id: convId,
		title: getConversationTitle(conversations[convId]),
		lastMessage: getLastMessage(conversations[convId]),
		createdAt: getConversationCreatedAt(conversations[convId])
	})).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
	

	

	
	// Debug logging
	$: console.log('Current conversation state:', {
		currentConversationId,
		currentNodeId,
		currentChatTreeSize: Object.keys(currentChatTree).length,
		messages: messages.length,
		totalConversations: Object.keys(conversations).length
	});
	


	// Load chat history from database
	async function loadChatHistory() {
		try {
			const response = await fetch('/api/chat');
			if (response.ok) {
				const conversationsWithMessages = await response.json();
				console.log('Loaded conversations from DB:', conversationsWithMessages);

				// Convert each conversation's messages to a tree
				conversations = {};
				conversationsWithMessages.forEach((conversation: any) => {
					if (conversation.messages && conversation.messages.length > 0) {
						conversations[conversation.id] = dbChatsToTree(conversation.messages);
					} else {
						conversations[conversation.id] = {};
					}
				});

				console.log('Converted conversations to trees:', conversations);

				// Set current conversation to the first one if none selected
				if (!currentConversationId && Object.keys(conversations).length > 0) {
					currentConversationId = Object.keys(conversations)[0];
					console.log('Set current conversation to:', currentConversationId);
				}
			} else {
				console.error('Failed to load chat history');
			}
		} catch (error) {
			console.error('Error loading chat history:', error);
		}
	}
	


	// Start a new conversation
	function startNewChat() {
		const newConversationId = crypto.randomUUID();
		conversations[newConversationId] = {};
		currentConversationId = newConversationId;
		currentNodeId = null;
		showHistory = false;
		editingMessageId = null;
		editingContent = '';
		console.log('Started new conversation:', newConversationId);
	}

	// Load a specific conversation
	function loadConversation(conversationId: string) {
		console.log('Loading conversation:', conversationId);

		if (conversations[conversationId]) {
			currentConversationId = conversationId;
			// Find the root message of this conversation
			const rootMessage = Object.values(conversations[conversationId]).find(node =>
				node.parentId === null
			);
			currentNodeId = rootMessage ? rootMessage.id : null;

			showHistory = false;
			editingMessageId = null;
			editingContent = '';
		}
	}

	// Load a specific branch
	function loadBranch(branchId: string) {
		if (currentChatTree[branchId]) {
			currentNodeId = branchId;
			showHistory = false;
			editingMessageId = null;
			editingContent = '';
			console.log('Loaded branch:', branchId);
		}
	}



	// Restore the full conversation when going back to the original
	function restoreFullConversation() {
		if (currentConversationId) {
			const rootMessage = Object.values(currentChatTree).find(node =>
				node.parentId === null
			);
			if (rootMessage) {
				currentNodeId = rootMessage.id;
				console.log('Restored to root conversation:', rootMessage.id);
			}
		}
	}

	// Flatten a conversation tree to linear array (for backward compatibility)
	function flattenConversation(conversation: ChatTreeNode): any[] {
		console.log('Flattening conversation:', conversation);
		const result: any[] = [];

		function traverse(node: ChatTreeNode) {
			console.log('Traversing node:', { id: node.id, role: node.role, content: node.content?.substring(0, 50) });
			const messageObj = {
				id: node.id,
				role: node.role,
				content: node.content,
				createdAt: node.createdAt,
				isEdited: node.isEdited,
				version: node.version
			};
			console.log('Created message object:', messageObj);
			result.push(messageObj);

			if (node.children && node.children.length > 0) {
				node.children.forEach(child => traverse(child));
			}
		}

		traverse(conversation);
		console.log('Final flattened result:', result);
		return result.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
	}

	// Start editing a user message
	function startEditing(message: any) {
		console.log('startEditing called with message:', message);
		console.log('Message keys:', Object.keys(message));
		console.log('Message ID:', message.id);
		console.log('Message role:', message.role);
		console.log('Message content:', message.content);
		
		// Check if this is a temporary message (not saved to database yet)
		if (message.id && message.id.startsWith('temp-')) {
			console.log('Cannot edit temporary message - wait for it to be saved to database');
			alert('Please wait for the message to be saved before editing. Try again in a moment.');
			return;
		}
		
		if (message.role === 'user') {
			editingMessageId = message.id;
			editingContent = message.content;
			console.log('Editing message ID set to:', editingMessageId);
			console.log('Editing content set to:', editingContent);
		} else {
			console.log('Cannot edit non-user message');
		}
	}

	// Cancel editing
	function cancelEditing() {
		editingMessageId = null;
		editingContent = '';
	}

	// Save edited message
	async function saveEditedMessage(message: any) {
		console.log('saveEditedMessage called with message:', message);
		console.log('Current editingMessageId:', editingMessageId);
		console.log('Current editingContent:', editingContent);

		if (!editingContent.trim() || editingContent === message.content) {
			console.log('No changes or empty content, canceling edit');
			cancelEditing();
			return;
		}

		try {
			isLoading = true;

			// Call the edit API to create a new branch
			console.log('Calling edit API with:', { messageId: editingMessageId, newContent: editingContent });
			const response = await fetch('/api/chat', {
				method: 'PUT',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					messageId: editingMessageId,
					newContent: editingContent
				})
			});

			if (response.ok) {
				// Reload chat history to get the updated tree structure
				await loadChatHistory();

				// Navigate to the new branch
				// The API creates a new message and AI response, so we need to find the new AI message
				const newAIMessage = Object.values(currentChatTree).find(node =>
					node.role === 'assistant' &&
					node.parentId === editingMessageId &&
					node.content.includes(editingContent)
				);

				if (newAIMessage) {
					currentNodeId = newAIMessage.id;
					console.log('Navigated to new AI response:', newAIMessage.id);
				}

				cancelEditing();
			} else {
				const error = await response.text();
				console.error('Failed to edit message:', error);
				alert('Failed to edit message. Please try again.');
			}
		} catch (error) {
			console.error('Error editing message:', error);
			alert('Error editing message. Please try again.');
		} finally {
			isLoading = false;
		}
	}

	async function handleChatSubmit(event: Event) {
		event.preventDefault();
		console.log('handleChatSubmit called with input:', input.trim());

		if (input.trim() && !isLoading) {
			const userMessage = input.trim();
			input = '';

			try {
				isLoading = true;

				// Generate conversation ID if this is a new chat
				let conversationId = currentConversationId;
				if (!conversationId) {
					conversationId = crypto.randomUUID();
					conversations[conversationId] = {};
					currentConversationId = conversationId;
					console.log('Generated new conversation ID:', conversationId);
				}

				// Call the API to send the message
				const response = await fetch('/api/chat', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						messages: [{ role: 'user', content: userMessage }],
						parentId: currentNodeId,
						conversationId: conversationId
					}),
				});

				if (response.ok) {
					// Reload chat history to get the updated tree structure
					await loadChatHistory();

					// Navigate to the latest AI response
					const latestAIMessage = Object.values(currentChatTree).find(node =>
						node.role === 'assistant' &&
						node.parentId &&
						currentChatTree[node.parentId]?.content === userMessage
					);

					if (latestAIMessage) {
						currentNodeId = latestAIMessage.id;
						console.log('Navigated to latest AI response:', latestAIMessage.id);
					}
				} else {
					const error = await response.text();
					console.error('Chat API error:', error);
					alert('Failed to send message. Please try again.');
				}
			} catch (error) {
				console.error('Chat error:', error);
				alert('Error sending message. Please try again.');
			} finally {
				isLoading = false;
			}
		}
	}

	// Navigation functions
	function goToPreviousBranch() {
		if (currentNodeId) {
			const parentId = goToParent(currentChatTree, currentNodeId);
			if (parentId) {
				currentNodeId = parentId;
				console.log('Navigated to parent:', parentId);
			}
		}
	}

	function goToNextBranch() {
		if (currentNodeId) {
			const nextId = goToNext(currentChatTree, currentNodeId);
			if (nextId) {
				currentNodeId = nextId;
				console.log('Navigated to next:', nextId);
			}
		}
	}

	// Load chat history on mount
	onMount(() => {
		loadChatHistory();
	});

	// Auto-scroll to bottom when messages change
	$: if (messages.length > 0) {
		setTimeout(() => {
			const chatContainer = document.getElementById('chat-container');
			if (chatContainer) {
				chatContainer.scrollTop = chatContainer.scrollHeight;
			}
		}, 100);
	}
</script>












<svelte:head>
	<title>Chatbot - AuthFlow Dashboard</title>
</svelte:head>
										// If they exist, update the IDs; if not, keep the temporary ones for now
										const realUserMessage = Object.values(conversations[currentConversationId]).find((msg: any) => 
											msg.role === 'user' && 
											msg.content === userMessage &&
											!msg.id.startsWith('temp-') &&
											msg.conversationId === currentConversationId
										);
										
										const realAIMessage = Object.values(conversations[currentConversationId]).find((msg: any) => 
											msg.role === 'assistant' && 
											msg.content === currentStreamingMessage &&
											!msg.id.startsWith('temp-') &&
											msg.conversationId === currentConversationId
										);
										
										if (realUserMessage && realAIMessage) {
											// Update current node to real AI message
											currentNodeId = realAIMessage.id;
											console.log('Found real IDs - User:', realUserMessage.id, 'AI:', realAIMessage.id);
										} else {
											console.log('Real IDs not found yet, keeping temporary IDs for now');
											console.log('This is normal - the database might need more time to update');
											
											// Instead of reloading all conversations (which overwrites our current state),
											// we'll make a targeted API call to get just the current conversation's messages
											setTimeout(async () => {
												console.log('Attempting to get updated conversation data...');
												
												try {
													// Make a targeted API call to get just this conversation's messages
													const response = await fetch(`/api/chat?conversationId=${currentConversationId}`);
													if (response.ok) {
														const conversationMessages = await response.json();
														console.log('Got updated conversation messages:', conversationMessages);
														
														// Find the real messages in the updated data
														const refreshedUserMessage = conversationMessages.find((msg: any) => 
															msg.role === 'user' && 
															msg.content === userMessage &&
															!msg.id.startsWith('temp-') &&
															msg.conversationId === currentConversationId
														);
														
														const refreshedAIMessage = conversationMessages.find((msg: any) => 
															msg.role === 'assistant' && 
															msg.content === currentStreamingMessage &&
															!msg.id.startsWith('temp-') &&
															msg.conversationId === currentConversationId
														);
														
														if (refreshedUserMessage && refreshedAIMessage) {
															// Update the conversation tree with real IDs while preserving current state
															conversations[currentConversationId] = {
																...conversations[currentConversationId],
																[refreshedUserMessage.id]: {
																	...conversations[currentConversationId][tempUserMessageId],
																	id: refreshedUserMessage.id
																},
																[refreshedAIMessage.id]: {
																	...conversations[currentConversationId][tempAIMessageId],
																	id: refreshedAIMessage.id,
																	parentId: refreshedUserMessage.id
																}
															};
															
															// Remove temporary messages
															delete conversations[currentConversationId][tempUserMessageId];
															delete conversations[currentConversationId][tempAIMessageId];
															
															// Update current node to real AI message
															currentNodeId = refreshedAIMessage.id;
															
															console.log('Successfully updated with real IDs:', refreshedUserMessage.id, refreshedAIMessage.id);
															console.log('Updated conversation tree:', conversations[currentConversationId]);
															
															// Force reactivity
															conversations = { ...conversations };
														} else {
															console.log('Real messages still not found in database');
														}
													} else {
														console.log('Failed to get updated conversation data');
													}
												} catch (error) {
													console.error('Error getting updated conversation data:', error);
												}
											}, 2000); // Wait 2 seconds before attempting refresh
										}
										
										break;
									}
									
									try {
										const parsed = JSON.parse(data);
										if (parsed.chunk) {
											currentStreamingMessage += parsed.chunk;
											// Update streaming content in conversation tree
											if (conversations[currentConversationId][tempAIMessageId]) {
												conversations[currentConversationId][tempAIMessageId].content = currentStreamingMessage;
												// Trigger reactivity
												conversations[currentConversationId] = { ...conversations[currentConversationId] };
											}
										}
									} catch (e) {
										console.error('Error parsing chunk:', e);
									}
								}
							}
						}
					}
				} else {
					const error = await response.text();
					console.error('API error response:', error);
					
					// Create error message in conversation tree
					const errorMessageId = 'temp-error-' + Date.now();
					conversations[currentConversationId] = {
						...conversations[currentConversationId],
						[errorMessageId]: {
							id: errorMessageId,
							parentId: tempUserMessageId,
							conversationId: currentConversationId,
							role: 'assistant',
							content: `Error: ${error || 'Failed to get response'}`,
							isEdited: false,
							originalContent: null,
							version: 1,
							isActive: true,
							branchOrder: (conversations[currentConversationId][tempUserMessageId]?.branchOrder || 0) + 1,
							createdAt: new Date(),
							children: []
						}
					};
					
					// Add error message as child of user message
					if (conversations[currentConversationId][tempUserMessageId]) {
						conversations[currentConversationId][tempUserMessageId].children.push(errorMessageId);
						// Trigger reactivity
						conversations[currentConversationId] = { ...conversations[currentConversationId] };
					}
					
					// Update current node to error message
					currentNodeId = errorMessageId;
				}
			} catch (error) {
				console.error('Chat error:', error);
				
				// Create error message in conversation tree
				const errorMessageId = 'temp-error-' + Date.now();
				conversations[currentConversationId] = {
					...conversations[currentConversationId],
					[errorMessageId]: {
						id: errorMessageId,
						parentId: tempUserMessageId,
						conversationId: currentConversationId,
						role: 'assistant',
						content: 'Sorry, I encountered an error. Please try again.',
						isEdited: false,
						originalContent: null,
						version: 1,
						isActive: true,
						branchOrder: (conversations[currentConversationId][tempUserMessageId]?.branchOrder || 0) + 1,
						createdAt: new Date(),
						children: []
					}
				};
				
				// Add error message as child of user message
				if (conversations[currentConversationId][tempUserMessageId]) {
					conversations[currentConversationId][tempUserMessageId].children.push(errorMessageId);
					// Trigger reactivity
					conversations[currentConversationId] = { ...conversations[currentConversationId] };
				}
				
				// Update current node to error message
				currentNodeId = errorMessageId;
			} finally {
				isLoading = false;
				currentStreamingMessage = '';
			}
		}
	}

	// Load chat history from database
	async function loadChatHistory() {
		try {
			const response = await fetch('/api/chat');
			if (response.ok) {
				const conversationsWithMessages = await response.json();
				console.log('Loaded conversations from DB:', conversationsWithMessages);

				// Convert each conversation's messages to a tree
				conversations = {};
				conversationsWithMessages.forEach((conversation: any) => {
					if (conversation.messages && conversation.messages.length > 0) {
						conversations[conversation.id] = dbChatsToTree(conversation.messages);
					} else {
						conversations[conversation.id] = {};
					}
				});

				console.log('Converted conversations to trees:', conversations);

				// Set current conversation to the first one if none selected
				if (!currentConversationId && Object.keys(conversations).length > 0) {
					currentConversationId = Object.keys(conversations)[0];
					console.log('Set current conversation to:', currentConversationId);
				}
			} else {
				console.error('Failed to load chat history');
			}
		} catch (error) {
			console.error('Error loading chat history:', error);
		}
	}

	// Start a new conversation
	function startNewChat() {
		const newConversationId = crypto.randomUUID();
		conversations[newConversationId] = {};
		currentConversationId = newConversationId;
		currentNodeId = null;
		showHistory = false;
		editingMessageId = null;
		editingContent = '';
		console.log('Started new conversation:', newConversationId);
	}

	// Load a specific conversation
	function loadConversation(conversationId: string) {
		console.log('Loading conversation:', conversationId);

		if (conversations[conversationId]) {
			currentConversationId = conversationId;
			// Find the root message of this conversation
			const rootMessage = Object.values(conversations[conversationId]).find(node =>
				node.parentId === null
			);
			currentNodeId = rootMessage ? rootMessage.id : null;

			showHistory = false;
			editingMessageId = null;
			editingContent = '';
		}
	}

	// Start editing a user message
	function startEditing(message: any) {
		console.log('startEditing called with message:', message);

		if (message.role === 'user') {
			editingMessageId = message.id;
			editingContent = message.content;
		} else {
			console.log('Cannot edit non-user message');
		}
	}

	// Cancel editing
	function cancelEditing() {
		editingMessageId = null;
		editingContent = '';
	}

	// Save edited message
	async function saveEditedMessage(message: any) {
		console.log('saveEditedMessage called with message:', message);

		if (!editingContent.trim() || editingContent === message.content) {
			console.log('No changes or empty content, canceling edit');
			cancelEditing();
			return;
		}

		try {
			isLoading = true;

			// Call the edit API to create a new branch
			console.log('Calling edit API with:', { messageId: editingMessageId, newContent: editingContent });
			const response = await fetch('/api/chat', {
				method: 'PUT',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					messageId: editingMessageId,
					newContent: editingContent
				})
			});

			if (response.ok) {
				// Reload chat history to get the updated tree structure
				await loadChatHistory();

				// Navigate to the new branch
				// The API creates a new message and AI response, so we need to find the new AI message
				const newAIMessage = Object.values(currentChatTree).find(node =>
					node.role === 'assistant' &&
					node.parentId === editingMessageId &&
					node.content.includes(editingContent)
				);

				if (newAIMessage) {
					currentNodeId = newAIMessage.id;
					console.log('Navigated to new AI response:', newAIMessage.id);
				}

				cancelEditing();
			} else {
				const error = await response.text();
				console.error('Failed to edit message:', error);
				alert('Failed to edit message. Please try again.');
			}
		} catch (error) {
			console.error('Error editing message:', error);
			alert('Error editing message. Please try again.');
		} finally {
			isLoading = false;
		}
	}

	async function handleChatSubmit(event: Event) {
		event.preventDefault();
		console.log('handleChatSubmit called with input:', input.trim());

		if (input.trim() && !isLoading) {
			const userMessage = input.trim();
			input = '';

			try {
				isLoading = true;

				// Generate conversation ID if this is a new chat
				let conversationId = currentConversationId;
				if (!conversationId) {
					conversationId = crypto.randomUUID();
					conversations[conversationId] = {};
					currentConversationId = conversationId;
					console.log('Generated new conversation ID:', conversationId);
				}

				// Call the API to send the message
				const response = await fetch('/api/chat', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						messages: [{ role: 'user', content: userMessage }],
						parentId: currentNodeId,
						conversationId: conversationId
					}),
				});

				if (response.ok) {
					// Reload chat history to get the updated tree structure
					await loadChatHistory();

					// Navigate to the latest AI response
					const latestAIMessage = Object.values(currentChatTree).find(node =>
						node.role === 'assistant' &&
						node.parentId &&
						currentChatTree[node.parentId]?.content === userMessage
					);

					if (latestAIMessage) {
						currentNodeId = latestAIMessage.id;
						console.log('Navigated to latest AI response:', latestAIMessage.id);
					}
				} else {
					const error = await response.text();
					console.error('Chat API error:', error);
					alert('Failed to send message. Please try again.');
				}
			} catch (error) {
				console.error('Chat error:', error);
				alert('Error sending message. Please try again.');
			} finally {
				isLoading = false;
			}
		}
	}

	// Navigation functions
	function goToPreviousBranch() {
		if (currentNodeId) {
			const parentId = goToParent(currentChatTree, currentNodeId);
			if (parentId) {
				currentNodeId = parentId;
				console.log('Navigated to parent:', parentId);
			}
		}
	}

	function goToNextBranch() {
		if (currentNodeId) {
			const nextId = goToNext(currentChatTree, currentNodeId);
			if (nextId) {
				currentNodeId = nextId;
				console.log('Navigated to next:', nextId);
			}
		}
	}

	// Load chat history on mount
	onMount(() => {
		loadChatHistory();
	});

	// Auto-scroll to bottom when messages change
	$: if (messages.length > 0) {
		setTimeout(() => {
			const chatContainer = document.getElementById('chat-container');
			if (chatContainer) {
				chatContainer.scrollTop = chatContainer.scrollHeight;
			}
		}, 100);
	}
</script>

<svelte:head>
	<title>Chatbot - AuthFlow Dashboard</title>
</svelte:head>

<div class="min-h-screen bg-gray-50 p-2 sm:p-4">
	<div class="max-w-7xl mx-auto h-[calc(100vh-6rem)] sm:h-[calc(100vh-8rem)] flex flex-col lg:flex-row">
		<!-- Chat History Sidebar -->
		{#if showHistory}
			<div class="w-full lg:w-80 bg-white rounded-t-xl lg:rounded-l-xl lg:rounded-t-none shadow-sm border-b-2 lg:border-r-2 lg:border-b-0 border-gray-100 flex flex-col flex-shrink-0">
				<div class="p-4 lg:p-6 border-b-2 border-gray-100">
					<div class="flex items-center justify-between mb-4">
						<h2 class="text-lg lg:text-xl font-semibold text-gray-900">Chat History</h2>
						<button
							on:click={startNewChat}
							class="px-3 lg:px-4 py-2 bg-gradient-to-r from-blue-600 to-blue-700 text-white rounded-lg hover:from-blue-700 hover:to-blue-800 transition-all duration-200 text-sm font-medium shadow-sm hover:shadow-md transform hover:scale-105 active:scale-95"
						>
							New Chat
						</button>
					</div>
					<p class="text-sm text-gray-600">Your previous conversations and branches</p>
				</div>
				
				<div class="flex-1 overflow-y-auto p-3 lg:p-4 space-y-3 max-h-64 lg:max-h-none">
					{#if conversationList.length === 0}
						<div class="text-center text-gray-500 py-6 lg:py-8">
							<div class="w-12 h-12 lg:w-16 lg:h-16 mx-auto mb-3 lg:mb-4 bg-gray-100 rounded-full flex items-center justify-center">
								<svg class="w-6 h-6 lg:w-8 lg:h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
								</svg>
							</div>
							<p class="text-sm">No conversations yet</p>
							<p class="text-xs text-gray-400">Start a new chat to begin</p>
						</div>
					{:else}
						{#each conversationList as conversation}
							<div class="space-y-2">
								<button
									on:click={() => loadConversation(conversation.id)}
									class="w-full text-left p-2 lg:p-3 rounded-lg hover:bg-blue-50 transition-all duration-200 border-2 border-gray-100 hover:border-blue-200 hover:shadow-sm"
								>
									<div class="flex items-start space-x-2 lg:space-x-3">
										<div class="w-6 h-6 lg:w-8 lg:h-8 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0">
											<svg class="w-3 h-3 lg:w-4 lg:h-4 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
												<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
											</svg>
										</div>
										<div class="flex-1 min-w-0">
											<div class="flex items-center space-x-2 mb-1">
												<p class="text-xs lg:text-sm font-medium text-gray-900 truncate">
													{conversation.title}
												</p>
											</div>
											<p class="text-xs text-gray-500">
												{conversation.lastMessage}
											</p>
											<p class="text-xs text-gray-400">
												{new Date(conversation.createdAt).toLocaleDateString()}
											</p>
										</div>
									</div>
								</button>
								
								<!-- Show available branches for this conversation -->
								{#if availableBranches.length > 0}
									{#each availableBranches.filter(b => b && b.id && conversation && conversation.id && b.id.startsWith(conversation.id)) as branch}
										<button
											on:click={() => loadBranch(branch.id)}
											class="w-full text-left p-1 lg:p-2 rounded-lg hover:bg-purple-50 transition-all duration-200 text-xs lg:text-sm border-2 border-gray-100 hover:border-purple-200 hover:shadow-sm ml-3 lg:ml-6"
										>
											<div class="flex items-start space-x-2">
												<div class="w-4 h-4 lg:w-6 lg:h-6 bg-purple-100 rounded-full flex items-center justify-center flex-shrink-0">
													<svg class="w-2 h-2 lg:w-3 lg:h-3 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
														<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
													</svg>
												</div>
												<div class="flex-1 min-w-0">
													<p class="text-xs lg:text-sm text-gray-700 truncate">
														Branch v{branch.id && branch.id.includes('-v') ? branch.id.split('-v')[1] : '1'}
													</p>
													<p class="text-xs text-gray-500">
														{branch.createdAt ? new Date(branch.createdAt).toLocaleDateString() : 'Unknown date'}
													</p>
												</div>
											</div>
										</button>
									{/each}
								{/if}
							</div>
						{/each}
					{/if}
				</div>
			</div>
		{/if}

		<!-- Main Chat Area -->
		<div class="flex-1 flex flex-col min-h-0">
			<!-- Chat Header -->
			<div class="bg-white rounded-b-xl lg:rounded-r-xl lg:rounded-b-none shadow-sm border-b-2 lg:border-b-0 border-gray-100 px-4 lg:px-6 py-3 lg:py-4 flex-shrink-0">
				<div class="flex items-center justify-between">
					<div class="flex items-center space-x-2 lg:space-x-3">
						{#if showHistory}
							<button
								on:click={() => showHistory = false}
								class="p-1.5 lg:p-2 hover:bg-gray-100 rounded-lg transition-colors text-gray-600 hover:text-gray-800"
								aria-label="Hide chat history sidebar"
							>
								<svg class="w-4 h-4 lg:w-5 lg:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
								</svg>
							</button>
						{:else}
							<button
								on:click={() => showHistory = true}
								class="p-1.5 lg:p-2 hover:bg-gray-100 rounded-lg transition-colors text-gray-600 hover:text-gray-800"
								aria-label="Show chat history sidebar"
							>
								<svg class="w-4 h-4 lg:w-5 lg:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
								</svg>
							</button>
						{/if}
						
						<div class="w-8 h-8 lg:w-12 lg:h-12 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center shadow-lg">
							<svg class="w-4 h-4 lg:w-6 lg:h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
							</svg>
						</div>
						<div>
							<h1 class="text-lg lg:text-2xl font-bold text-gray-900">AI Assistant</h1>
							<p class="text-xs lg:text-sm text-gray-600">Powered by Gemini 2.0 Flash</p>
						</div>
					</div>
					
					<!-- Branch Navigation -->
					{#if currentNodeId && navigationInfo.hasParent}
						<div class="flex items-center space-x-2">
							<button
								on:click={goToPreviousBranch}
								disabled={!navigationInfo.hasParent}
								class="p-2 hover:bg-gray-100 rounded-lg transition-colors text-gray-600 hover:text-gray-800 disabled:opacity-50 disabled:cursor-not-allowed"
								title="Go to parent message"
							>
								<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
								</svg>
							</button>
							
							<span class="text-xs text-gray-500 font-medium">
								{currentNodeId ? "Branch View" : "Main Conversation"}
							</span>
							
							<button
								on:click={goToNextBranch}
								disabled={!navigationInfo.hasNext}
								class="p-2 hover:bg-gray-100 rounded-lg transition-colors text-gray-600 hover:text-gray-800 disabled:opacity-50 disabled:cursor-not-allowed"
								title="Go to next message"
							>
								<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
								</svg>
							</button>
							
							<button
								on:click={restoreFullConversation}
								class="px-3 py-1.5 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg transition-colors font-medium"
								title="Back to full conversation"
							>
								<svg class="w-3 h-3 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
								</svg>
								Full Chat
							</button>
						</div>
					{/if}
					
					<div class="flex items-center space-x-2">
						<div class="w-2 h-2 lg:w-3 lg:h-3 bg-green-500 rounded-full animate-pulse"></div>
						<span class="text-xs lg:text-sm text-gray-600 font-medium">Online</span>
					</div>
				</div>
			</div>

			<!-- Chat Messages Area -->
			<div class="flex-1 bg-white overflow-hidden min-h-0">
				<div id="chat-container" class="h-full overflow-y-auto p-3 lg:p-6 space-y-4 lg:space-y-6">
					<!-- Debug info -->
					<div class="bg-yellow-100 p-2 rounded text-xs text-gray-700 mb-4">
						<strong>Debug:</strong> Tree size: {Object.keys(currentChatTree).length} | 
						Current node: {currentNodeId || 'null'} | 
						Messages: {messages.length} | 
						Display: {displayMessages.length} | 
						Conversation: {currentConversationId || 'null'}
					</div>
					
					{#if displayMessages.length === 0}
						<div class="flex flex-col items-center justify-center h-full text-center text-gray-500 px-4">
							<div class="w-16 h-16 lg:w-24 lg:h-24 mx-auto mb-4 lg:mb-6 bg-gradient-to-br from-blue-100 to-purple-100 rounded-full flex items-center justify-center">
								<svg class="w-8 h-8 lg:w-12 lg:h-12 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
								</svg>
							</div>
							<h2 class="text-lg lg:text-2xl font-semibold text-gray-700 mb-2">Welcome to AI Assistant</h2>
							<p class="text-base lg:text-lg text-gray-500 mb-3 lg:mb-4">I'm here to help you with any questions or tasks</p>
							<div class="max-w-md">
								<p class="text-xs lg:text-sm text-gray-400 leading-relaxed">
									You can ask me about programming, writing, analysis, or just have a friendly conversation. 
									I'm powered by Google's latest Gemini 2.0 Flash model for the best possible responses.
								</p>
							</div>
							<div class="mt-4 p-2 bg-red-100 rounded text-xs">
								<strong>Debug:</strong> Tree has {Object.keys(currentChatTree).length} nodes but no display messages
							</div>
						</div>
					{/if}

					{#each displayMessages as message}
						<div class="flex {message.role === 'user' ? 'justify-end' : 'justify-start'}">
							<div class="max-w-xs sm:max-w-md lg:max-w-2xl px-3 lg:px-6 py-3 lg:py-4 rounded-2xl {message.role === 'user' ? 'bg-blue-600 text-white shadow-lg' : message.isError ? 'bg-red-50 text-red-800 border-2 border-red-200' : 'bg-white text-gray-800 border-2 border-gray-100 shadow-sm hover:shadow-md transition-shadow'}">
								{#if message.role === 'user'}
									<div class="flex items-center space-x-2 lg:space-x-3 mb-2">
										<div class="w-6 h-6 lg:w-8 lg:h-8 bg-white/20 rounded-full flex items-center justify-center">
											<svg class="w-3 h-3 lg:w-4 lg:h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
												<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
											</svg>
										</div>
										<span class="text-xs lg:text-sm font-semibold text-white">You</span>
										{#if message.isEdited}
											<span class="text-xs text-white/70 bg-white/20 px-2 py-1 rounded-full">Edited</span>
										{/if}
										{#if message.version && message.version > 1}
											<span class="text-xs text-white/70 bg-white/20 px-2 py-1 rounded-full">v{message.version}</span>
										{/if}
									</div>
									
									{#if editingMessageId === message.id}
										<!-- Edit Mode -->
										<div class="space-y-3">
											<textarea
												bind:value={editingContent}
												class="w-full px-3 py-2 text-gray-800 rounded-lg border-2 border-blue-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none resize-none"
												rows="3"
												placeholder="Edit your message..."
											></textarea>
											<div class="flex space-x-2">
												<button
													on:click={() => saveEditedMessage(message)}
													disabled={isLoading}
													class="px-3 py-1.5 bg-green-600 hover:bg-green-700 text-white text-xs rounded-lg transition-colors disabled:opacity-50"
												>
													{#if isLoading}
														<svg class="w-3 h-3 animate-spin inline mr-1" fill="none" viewBox="0 0 24 24">
															<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
															<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
														</svg>
													{/if}
													Save
												</button>
												<button
													on:click={cancelEditing}
													disabled={isLoading}
													class="px-3 py-1.5 bg-gray-600 hover:bg-gray-700 text-white text-xs rounded-lg transition-colors disabled:opacity-50"
												>
													Cancel
												</button>
											</div>
										</div>
									{:else}
										<!-- Display Mode -->
										<div class="prose prose-sm max-w-none">
											<div class="text-sm lg:text-base leading-relaxed whitespace-pre-wrap text-white font-medium">
												{message.content}
											</div>
										</div>
										
										<div class="mt-2 lg:mt-3 pt-2 lg:pt-3 border-t border-white/30 flex items-center justify-between">
											{#if message.id && message.id.startsWith('temp-')}
												<button
													disabled
													class="text-xs text-white/50 font-medium flex items-center space-x1 px-1.5 lg:px-2 py-1 rounded cursor-not-allowed"
													title="Wait for message to be saved before editing"
												>
													<svg class="w-2.5 h-2.5 lg:w-3 lg:h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
														<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
													</svg>
													<span>Saving...</span>
												</button>
											{:else}
												<div class="flex items-center space-x-2">
													<button
														on:click={() => startEditing(message)}
														class="text-xs text-white hover:text-blue-100 font-medium flex items-center space-x-1 hover:bg-white/20 px-1.5 lg:px-2 py-1 rounded transition-colors"
													>
														<svg class="w-2.5 h-2.5 lg:w-3 lg:h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
															<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
														</svg>
														<span>Edit</span>
													</button>
													
													<!-- Navigation arrows for edited messages -->
													{#if message.isEdited && navigationInfo.hasParent}
														<div class="flex items-center space-x-1 ml-2">
															<button
																on:click={goToPreviousBranch}
																class="text-xs text-white/70 hover:text-white font-medium flex items-center space-x-1 hover:bg-white/20 px-1.5 py-1 rounded transition-colors"
																title="Go to parent message"
															>
																<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
																	<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
																</svg>
															</button>
															<span class="text-xs text-white/50 px-1">
																v{message.version || 1}
															</span>
															<button
																on:click={goToNextBranch}
																class="text-xs text-white/70 hover:text-white font-medium flex items-center space-x-1 hover:bg-white/20 px-1.5 py-1 rounded transition-colors"
																title="Go to next message"
															>
																<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
																	<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
																</svg>
															</button>
														</div>
													{/if}
												</div>
											{/if}
										</div>
									{/if}
								{:else}
									<div class="flex items-center space-x-2 lg:space-x-3 mb-2">
										<div class="w-6 h-6 lg:w-8 lg:h-8 {message.isError ? 'bg-red-100' : 'bg-gradient-to-br from-blue-500 to-purple-600'} rounded-full flex items-center justify-center">
											{#if message.isError}
												<svg class="w-3 h-3 lg:w-4 lg:h-4 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
												</svg>
											{:else}
												<svg class="w-3 h-3 lg:w-4 lg:h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
												</svg>
											{/if}
										</div>
										<span class="text-xs lg:text-sm font-semibold {message.isError ? 'text-red-600' : 'text-blue-600'}">
											{message.isError ? 'Error' : 'AI Assistant'}
										</span>
									</div>
									<MessageRenderer 
										content={message.content} 
										isLoading={message.isLoading} 
										isError={message.isError} 
									/>
								{/if}
							</div>
						</div>
					{/each}

					{#if isLoading && currentStreamingMessage === ''}
						<div class="flex justify-start">
							<div class="max-w-xs sm:max-w-md lg:max-w-2xl px-3 lg:px-6 py-3 lg:py-4 rounded-2xl bg-white border-2 border-gray-100 shadow-sm hover:shadow-md transition-shadow">
								<div class="flex items-center space-x-2 lg:space-x-3 mb-2">
									<div class="w-6 h-6 lg:w-8 lg:h-8 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center">
										<svg class="w-3 h-3 lg:w-4 lg:h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
											<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
										</svg>
									</div>
									<span class="text-xs lg:text-sm font-semibold text-blue-600">AI Assistant</span>
								</div>
								<div class="flex items-center space-x-2">
									<span class="text-sm lg:text-base text-gray-700 font-medium">Thinking</span>
									<div class="flex space-x-1">
										<div class="w-1.5 h-1.5 lg:w-2 lg:h-2 bg-blue-500 rounded-full animate-bounce"></div>
										<div class="w-1.5 h-1.5 lg:w-2 lg:h-2 bg-blue-500 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
										<div class="w-1.5 h-1.5 lg:w-2 lg:h-2 bg-blue-500 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
									</div>
								</div>
							</div>
						</div>
					{/if}
				</div>
			</div>

			<!-- Chat Input -->
			<div class="bg-white rounded-b-xl lg:rounded-br-xl shadow-sm border-t-2 border-gray-100 p-3 lg:p-6 flex-shrink-0">
				<form on:submit={handleChatSubmit} class="flex space-x-2 lg:space-x-4">
					<div class="flex-1 relative">
						<input
							bind:value={input}
							type="text"
							placeholder="Ask me anything... I'm here to help!"
							class="w-full px-3 lg:px-6 py-3 lg:py-4 text-base lg:text-lg border-2 border-gray-200 rounded-xl lg:rounded-2xl focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all duration-200 resize-none hover:border-gray-300 focus:shadow-md"
							disabled={isLoading}
						/>
						{#if input.trim()}
							<button
								type="button"
								on:click={() => input = ''}
								class="absolute right-2 lg:right-4 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 transition-colors p-1 hover:bg-gray-100 rounded-full"
								aria-label="Clear input text"
							>
								<svg class="w-4 h-4 lg:w-5 lg:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
								</svg>
							</button>
						{/if}
					</div>
					<button
						type="submit"
						disabled={!input.trim() || isLoading}
						class="px-4 lg:px-8 py-3 lg:py-4 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-xl lg:rounded-2xl font-semibold hover:from-blue-700 hover:to-purple-700 focus:ring-4 focus:ring-blue-500/20 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 flex items-center space-x-2 lg:space-x-3 shadow-lg hover:shadow-xl text-sm lg:text-base transform hover:scale-105 active:scale-95"
					>
						{#if isLoading}
							<svg class="w-4 h-4 lg:w-5 lg:h-5 animate-spin" fill="none" viewBox="0 0 24 24">
								<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
								<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
							</svg>
							<span class="hidden sm:inline">Thinking...</span>
						{:else}
							<svg class="w-4 h-4 lg:w-5 lg:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
							</svg>
							<span class="hidden sm:inline">Send</span>
						{/if}
					</button>
				</form>
			</div>
		</div>
	</div>
</div>
